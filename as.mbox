From 1f1e366702f40551c0a0d2c4170614229ca8ce57 Mon Sep 17 00:00:00 2001
From: Yang Bo <bo@hyper.sh>
Date: Thu, 20 Sep 2018 15:46:46 +0800
Subject: [PATCH 1/4] Add framework to support address space operation

Signed-off-by: Yang Bo <bo@hyper.sh>
---
 arch/x86/entry/syscalls/syscall_64.tbl |  6 ++++
 mm/Makefile                            |  2 ++
 mm/as.c                                | 50 ++++++++++++++++++++++++++
 3 files changed, 58 insertions(+)
 create mode 100644 mm/as.c

diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 4dfe42666d0c..3ee0ebc2d6f1 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -341,6 +341,12 @@
 330	common	pkey_alloc		__x64_sys_pkey_alloc
 331	common	pkey_free		__x64_sys_pkey_free
 332	common	statx			__x64_sys_statx
+333 common  as_create       __x64_sys_as_create
+334 common  as_mmap         __x64_sys_as_mmap
+335 common  as_munmap       __x64_sys_as_munmap
+336 common  as_mprotect     __x64_sys_as_mprotect
+337 common  as_switch_mm    __x64_sys_as_switch_mm
+338 common  as_destroy      __x64_sys_as_destroy
 
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
diff --git a/mm/Makefile b/mm/Makefile
index b4e54a9ae9c5..86767011896e 100644
--- a/mm/Makefile
+++ b/mm/Makefile
@@ -49,6 +49,8 @@ else
 	obj-y		+= bootmem.o
 endif
 
+obj-y += as.o
+
 obj-$(CONFIG_ADVISE_SYSCALLS)	+= fadvise.o
 ifdef CONFIG_MMU
 	obj-$(CONFIG_ADVISE_SYSCALLS)	+= madvise.o
diff --git a/mm/as.c b/mm/as.c
new file mode 100644
index 000000000000..45002ecee82b
--- /dev/null
+++ b/mm/as.c
@@ -0,0 +1,50 @@
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/sched/mm.h>
+#include <linux/syscalls.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/smp.h>
+#include <linux/sem.h>
+#include <linux/msg.h>
+#include <linux/mman.h>
+#include <linux/stat.h>
+#include <linux/file.h>
+#include <linux/personality.h>
+#include <linux/random.h>
+#include <linux/uaccess.h>
+#include <asm/syscalls.h>
+
+struct mmap_info;
+
+SYSCALL_DEFINE0(as_create)
+{
+    return -ENOSYS;
+}
+
+SYSCALL_DEFINE2(as_mmap, unsigned int, fd, struct mmap_info __user *, info)
+{
+    return -ENOSYS;
+}
+
+SYSCALL_DEFINE3(as_munmap, unsigned  int, fd, unsigned long, addr, 
+                unsigned long, len)
+{
+    return -ENOSYS;
+}
+
+SYSCALL_DEFINE4(as_mprotect, unsigned int, fd, unsigned long, addr,
+                unsigned long, len, unsigned int, prot)
+{
+    return -ENOSYS;
+}
+
+SYSCALL_DEFINE1(as_switch_mm, unsigned int, fd)
+{
+    return -ENOSYS;
+}
+
+SYSCALL_DEFINE1(as_destroy, unsigned int, fd)
+{
+    return -ENOSYS;
+}
-- 
2.19.0.rc1


From 32295c9dfd8e785e98b36294d3e8decbdec37287 Mon Sep 17 00:00:00 2001
From: Yang Bo <bo@hyper.sh>
Date: Thu, 20 Sep 2018 19:01:58 +0800
Subject: [PATCH 2/4] Prepare APIs for address space m{,un}map.

Signed-off-by: Yang Bo <bo@hyper.sh>
---
 include/linux/mm.h       | 18 +++++++++++++++++
 include/linux/syscalls.h |  4 ++++
 mm/internal.h            |  5 +++++
 mm/mmap.c                | 43 ++++++++++++++++++++++++++++++----------
 mm/mprotect.c            | 16 ++++++++++-----
 mm/util.c                | 14 +++++++++----
 6 files changed, 80 insertions(+), 20 deletions(-)

diff --git a/include/linux/mm.h b/include/linux/mm.h
index 28477ff9cf04..2186d9c71759 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2223,12 +2223,21 @@ extern unsigned long get_unmapped_area(struct file *, unsigned long, unsigned lo
 extern unsigned long mmap_region(struct file *file, unsigned long addr,
 	unsigned long len, vm_flags_t vm_flags, unsigned long pgoff,
 	struct list_head *uf);
+extern unsigned long mmap_region2(struct mm_struct *mm, struct file *file,
+    unsigned long addr, unsigned long len, vm_flags_t vm_flags,
+    unsigned long pgoff, struct list_head *uf);
 extern unsigned long do_mmap(struct file *file, unsigned long addr,
 	unsigned long len, unsigned long prot, unsigned long flags,
 	vm_flags_t vm_flags, unsigned long pgoff, unsigned long *populate,
 	struct list_head *uf);
+extern unsigned long do_mmap2(struct mm_struct *mm, struct file *file,
+    unsigned long addr, unsigned long len, unsigned long prot,
+    unsigned long flags, vm_flags_t vm_flags, unsigned long pgoff,
+    unsigned long *populate, struct list_head *uf);
 extern int do_munmap(struct mm_struct *, unsigned long, size_t,
 		     struct list_head *uf);
+extern int do_mprotect_pkey2(struct mm_struct *mm, unsigned long start, size_t len,
+		unsigned long prot, int pkey);
 
 static inline unsigned long
 do_mmap_pgoff(struct file *file, unsigned long addr,
@@ -2239,6 +2248,15 @@ do_mmap_pgoff(struct file *file, unsigned long addr,
 	return do_mmap(file, addr, len, prot, flags, 0, pgoff, populate, uf);
 }
 
+static inline unsigned long
+do_mmap_pgoff2(struct mm_struct *mm, struct file *file, unsigned long addr,
+	unsigned long len, unsigned long prot, unsigned long flags,
+	unsigned long pgoff, unsigned long *populate,
+	struct list_head *uf)
+{
+	return do_mmap2(mm, file, addr, len, prot, flags, 0, pgoff, populate, uf);
+}
+
 #ifdef CONFIG_MMU
 extern int __mm_populate(unsigned long addr, unsigned long len,
 			 int ignore_errors);
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 70fcda1a9049..48f75294ce1f 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -67,6 +67,7 @@ struct perf_event_attr;
 struct file_handle;
 struct sigaltstack;
 union bpf_attr;
+struct mm_struct;
 
 #include <linux/types.h>
 #include <linux/aio_abi.h>
@@ -1147,6 +1148,9 @@ static inline int ksys_fadvise64_64(int fd, loff_t offset, loff_t len,
 unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,
 			      unsigned long prot, unsigned long flags,
 			      unsigned long fd, unsigned long pgoff);
+unsigned long ksys_mmap_pgoff2(struct mm_struct *mm, unsigned long addr,
+                  unsigned long len, unsigned long prot, unsigned long flags,
+			      unsigned long fd, unsigned long pgoff);
 ssize_t ksys_readahead(int fd, loff_t offset, size_t count);
 
 /*
diff --git a/mm/internal.h b/mm/internal.h
index 502d14189794..2cd4a59067b6 100644
--- a/mm/internal.h
+++ b/mm/internal.h
@@ -469,6 +469,11 @@ extern unsigned long  __must_check vm_mmap_pgoff(struct file *, unsigned long,
         unsigned long, unsigned long,
         unsigned long, unsigned long);
 
+extern unsigned long  __must_check vm_mmap_pgoff2(struct mm_struct *mm,
+        struct file *, unsigned long,
+        unsigned long, unsigned long,
+        unsigned long, unsigned long);
+
 extern void set_pageblock_order(void);
 unsigned long reclaim_clean_pages_from_list(struct zone *zone,
 					    struct list_head *page_list);
diff --git a/mm/mmap.c b/mm/mmap.c
index 55d68c24e742..481c47b7a915 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -1356,13 +1356,12 @@ static inline bool file_mmap_ok(struct file *file, struct inode *inode,
 /*
  * The caller must hold down_write(&current->mm->mmap_sem).
  */
-unsigned long do_mmap(struct file *file, unsigned long addr,
-			unsigned long len, unsigned long prot,
+unsigned long do_mmap2(struct mm_struct *mm, struct file *file,
+            unsigned long addr, unsigned long len, unsigned long prot,
 			unsigned long flags, vm_flags_t vm_flags,
 			unsigned long pgoff, unsigned long *populate,
 			struct list_head *uf)
 {
-	struct mm_struct *mm = current->mm;
 	int pkey = 0;
 
 	*populate = 0;
@@ -1532,7 +1531,7 @@ unsigned long do_mmap(struct file *file, unsigned long addr,
 			vm_flags |= VM_NORESERVE;
 	}
 
-	addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);
+	addr = mmap_region2(mm, file, addr, len, vm_flags, pgoff, uf);
 	if (!IS_ERR_VALUE(addr) &&
 	    ((vm_flags & VM_LOCKED) ||
 	     (flags & (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))
@@ -1540,8 +1539,18 @@ unsigned long do_mmap(struct file *file, unsigned long addr,
 	return addr;
 }
 
-unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,
-			      unsigned long prot, unsigned long flags,
+unsigned long do_mmap(struct file *file, unsigned long addr,
+            unsigned long len, unsigned long prot,
+			unsigned long flags, vm_flags_t vm_flags,
+			unsigned long pgoff, unsigned long *populate,
+			struct list_head *uf)
+{
+    return do_mmap2(current->mm, file, addr, len, prot, flags, vm_flags,
+                    pgoff, populate, uf);
+}
+
+unsigned long ksys_mmap_pgoff2(struct mm_struct *mm, unsigned long addr,
+                  unsigned long len, unsigned long prot, unsigned long flags,
 			      unsigned long fd, unsigned long pgoff)
 {
 	struct file *file = NULL;
@@ -1582,13 +1591,20 @@ unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,
 
 	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
 
-	retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	retval = vm_mmap_pgoff2(mm, file, addr, len, prot, flags, pgoff);
 out_fput:
 	if (file)
 		fput(file);
 	return retval;
 }
 
+unsigned long ksys_mmap_pgoff(unsigned long addr, unsigned long len,
+			      unsigned long prot, unsigned long flags,
+			      unsigned long fd, unsigned long pgoff)
+{
+    return ksys_mmap_pgoff2(current->mm, addr, len, prot, flags, fd, pgoff);
+}
+
 SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,
 		unsigned long, prot, unsigned long, flags,
 		unsigned long, fd, unsigned long, pgoff)
@@ -1674,11 +1690,10 @@ static inline int accountable_mapping(struct file *file, vm_flags_t vm_flags)
 	return (vm_flags & (VM_NORESERVE | VM_SHARED | VM_WRITE)) == VM_WRITE;
 }
 
-unsigned long mmap_region(struct file *file, unsigned long addr,
-		unsigned long len, vm_flags_t vm_flags, unsigned long pgoff,
-		struct list_head *uf)
+unsigned long mmap_region2(struct mm_struct *mm, struct file *file,
+        unsigned long addr, unsigned long len, vm_flags_t vm_flags,
+        unsigned long pgoff, struct list_head *uf)
 {
-	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma, *prev;
 	int error;
 	struct rb_node **rb_link, *rb_parent;
@@ -1837,6 +1852,12 @@ unsigned long mmap_region(struct file *file, unsigned long addr,
 	return error;
 }
 
+unsigned long mmap_region(struct file *file, unsigned long addr,
+		unsigned long len, vm_flags_t vm_flags, unsigned long pgoff,
+		struct list_head *uf)
+{
+    return mmap_region2(current->mm, file, addr, len, vm_flags, pgoff, uf);
+}
 unsigned long unmapped_area(struct vm_unmapped_area_info *info)
 {
 	/*
diff --git a/mm/mprotect.c b/mm/mprotect.c
index 6d331620b9e5..cbe12bd05287 100644
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@ -453,7 +453,7 @@ mprotect_fixup(struct vm_area_struct *vma, struct vm_area_struct **pprev,
 /*
  * pkey==-1 when doing a legacy mprotect()
  */
-static int do_mprotect_pkey(unsigned long start, size_t len,
+int do_mprotect_pkey2(struct mm_struct *mm, unsigned long start, size_t len,
 		unsigned long prot, int pkey)
 {
 	unsigned long nstart, end, tmp, reqprot;
@@ -480,7 +480,7 @@ static int do_mprotect_pkey(unsigned long start, size_t len,
 
 	reqprot = prot;
 
-	if (down_write_killable(&current->mm->mmap_sem))
+	if (down_write_killable(&mm->mmap_sem))
 		return -EINTR;
 
 	/*
@@ -488,10 +488,10 @@ static int do_mprotect_pkey(unsigned long start, size_t len,
 	 * them use it here.
 	 */
 	error = -EINVAL;
-	if ((pkey != -1) && !mm_pkey_is_allocated(current->mm, pkey))
+	if ((pkey != -1) && !mm_pkey_is_allocated(mm, pkey))
 		goto out;
 
-	vma = find_vma(current->mm, start);
+	vma = find_vma(mm, start);
 	error = -ENOMEM;
 	if (!vma)
 		goto out;
@@ -570,10 +570,16 @@ static int do_mprotect_pkey(unsigned long start, size_t len,
 		prot = reqprot;
 	}
 out:
-	up_write(&current->mm->mmap_sem);
+	up_write(&mm->mmap_sem);
 	return error;
 }
 
+static int do_mprotect_pkey(unsigned long start, size_t len,
+		unsigned long prot, int pkey)
+{
+    return do_mprotect_pkey2(current->mm, start, len, prot, pkey);
+}
+
 SYSCALL_DEFINE3(mprotect, unsigned long, start, size_t, len,
 		unsigned long, prot)
 {
diff --git a/mm/util.c b/mm/util.c
index 45fc3169e7b0..66afd4f9f7f2 100644
--- a/mm/util.c
+++ b/mm/util.c
@@ -341,12 +341,11 @@ int __weak get_user_pages_fast(unsigned long start,
 }
 EXPORT_SYMBOL_GPL(get_user_pages_fast);
 
-unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,
-	unsigned long len, unsigned long prot,
+unsigned long vm_mmap_pgoff2(struct mm_struct *mm, struct file *file,
+    unsigned long addr, unsigned long len, unsigned long prot,
 	unsigned long flag, unsigned long pgoff)
 {
 	unsigned long ret;
-	struct mm_struct *mm = current->mm;
 	unsigned long populate;
 	LIST_HEAD(uf);
 
@@ -354,7 +353,7 @@ unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,
 	if (!ret) {
 		if (down_write_killable(&mm->mmap_sem))
 			return -EINTR;
-		ret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,
+		ret = do_mmap_pgoff2(mm, file, addr, len, prot, flag, pgoff,
 				    &populate, &uf);
 		up_write(&mm->mmap_sem);
 		userfaultfd_unmap_complete(mm, &uf);
@@ -364,6 +363,13 @@ unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,
 	return ret;
 }
 
+unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,
+	unsigned long len, unsigned long prot,
+	unsigned long flag, unsigned long pgoff)
+{
+    return vm_mmap_pgoff2(current->mm, file, addr, len, prot, flag, pgoff);
+}
+
 unsigned long vm_mmap(struct file *file, unsigned long addr,
 	unsigned long len, unsigned long prot,
 	unsigned long flag, unsigned long offset)
-- 
2.19.0.rc1


From 2864a20672cc3988298816175bb857223c7d271e Mon Sep 17 00:00:00 2001
From: Yang Bo <bo@hyper.sh>
Date: Fri, 21 Sep 2018 14:50:42 +0800
Subject: [PATCH 3/4] Implement address space syscalls.

Signed-off-by: Yang Bo <bo@hyper.sh>
---
 mm/as.c | 183 +++++++++++++++++++++++++++++++++++++++++++++++++++++---
 mm/as.h |  18 ++++++
 2 files changed, 193 insertions(+), 8 deletions(-)
 create mode 100644 mm/as.h

diff --git a/mm/as.c b/mm/as.c
index 45002ecee82b..016fc7eb5547 100644
--- a/mm/as.c
+++ b/mm/as.c
@@ -13,38 +13,205 @@
 #include <linux/personality.h>
 #include <linux/random.h>
 #include <linux/uaccess.h>
+#include <linux/mmu_context.h>
+#include <linux/vmacache.h>
+#include <linux/anon_inodes.h>
 #include <asm/syscalls.h>
+#include <asm/mmu_context.h>
+#include "as.h"
 
-struct mmap_info;
+// static long mm_nr = 0;
+
+static int as_release(struct inode *inode, struct file *file);
+struct file_operations as_fops = {
+    .release = as_release,
+    };
+
+
+static struct mm_struct *get_mm_from_fd(int fd)
+{
+    struct file *f;
+    struct mm_struct *mm = ERR_PTR(-EBADF);
+
+    f = fget(fd);
+    if (!f) {
+        return mm;
+    }
+
+    if (f->f_op != &as_fops) {
+        mm = ERR_PTR(-EINVAL);
+        goto out;
+    }
+
+    mm = f->private_data;
+
+out:
+    fput(f);
+    return mm;
+}
 
 SYSCALL_DEFINE0(as_create)
 {
-    return -ENOSYS;
+    int fd;
+    struct mm_struct *mm;
+
+    mm = mm_alloc();
+    if (!mm) {
+        return -ENOMEM;
+    }
+
+    fd = anon_inode_getfd("[adress-space]", &as_fops, mm, 0);
+    if (fd < 0) {
+        mmput(mm);
+        return fd;
+    }
+
+
+    /* add to mmlist? */
+    spin_lock(&mmlist_lock);
+    list_add(&mm->mmlist, &current->mm->mmlist);
+    /* looks like we will never go back to the initial mm..
+     * Therefore, let it vanish
+     * */
+#if 0
+    if (!mm_nr) {
+        mmget(current->mm);
+        mm_nr++;
+    }
+#endif
+    spin_unlock(&mmlist_lock);
+
+    return fd;
 }
 
 SYSCALL_DEFINE2(as_mmap, unsigned int, fd, struct mmap_info __user *, info)
 {
-    return -ENOSYS;
+    struct mmap_info kinfo;
+    struct mm_struct *mm;
+
+    if (copy_from_user(&kinfo, info, sizeof(struct mmap_info))) {
+        return -EFAULT;
+    }
+
+    mm = get_mm_from_fd(fd);
+    if (IS_ERR(mm)) {
+        return PTR_ERR(mm);
+    }
+
+    return ksys_mmap_pgoff2(mm, kinfo.addr, kinfo.len, kinfo.prot, kinfo.flags,
+                                kinfo.fd, kinfo.offset >> PAGE_SHIFT);
 }
 
-SYSCALL_DEFINE3(as_munmap, unsigned  int, fd, unsigned long, addr, 
+SYSCALL_DEFINE3(as_munmap, unsigned  int, fd, unsigned long, addr,
                 unsigned long, len)
 {
-    return -ENOSYS;
+    struct mm_struct *mm;
+    int ret;
+
+    mm = get_mm_from_fd(fd);
+    if (IS_ERR(mm)) {
+        return PTR_ERR(mm);
+    }
+
+    if (down_write_killable(&mm->mmap_sem)) {
+        return -EINTR;
+    }
+
+    ret = do_munmap(mm, addr, len, NULL);
+
+    up_write(&mm->mmap_sem);
+
+    return ret;
 }
 
 SYSCALL_DEFINE4(as_mprotect, unsigned int, fd, unsigned long, addr,
                 unsigned long, len, unsigned int, prot)
 {
-    return -ENOSYS;
+    struct mm_struct *mm;
+
+    mm = get_mm_from_fd(fd);
+    if (IS_ERR(mm)) {
+        return PTR_ERR(mm);
+    }
+
+    return do_mprotect_pkey2(mm, addr, len, prot, -1);;
 }
 
 SYSCALL_DEFINE1(as_switch_mm, unsigned int, fd)
 {
-    return -ENOSYS;
+    struct mm_struct *mm, *old_mm, *active_mm;
+    struct task_struct *tsk = current;
+
+    mm = get_mm_from_fd(fd);
+    if (IS_ERR(mm)) {
+        return PTR_ERR(mm);
+    }
+
+    old_mm = tsk->mm;
+
+    if (mm == old_mm || mm == tsk->active_mm) {
+        return 0;
+    }
+
+    mm_release(tsk, old_mm);
+
+    /* we are not kernel thread.
+     * we definitely have task->mm and task->active_mm..
+     * and mm == active_mm.
+     * */
+    if (old_mm) {
+        sync_mm_rss(old_mm);
+        down_read(&old_mm->mmap_sem);
+        mmget(mm);
+    } else {
+        mmgrab(mm);
+    }
+
+    task_lock(tsk);
+    active_mm = tsk->active_mm;
+    tsk->mm = mm;
+    tsk->active_mm = mm;
+    activate_mm(active_mm, mm);
+    tsk->mm->vmacache_seqnum = 0;
+    vmacache_flush(tsk);
+    task_unlock(tsk);
+
+    /* simply mmput/mmdrop will cause the initial mm of this task
+     * vanish.. hmmm.. Not sure if need to keep it.
+     * */
+    if (old_mm) {
+        up_read(&old_mm->mmap_sem);
+        BUG_ON(active_mm != old_mm);
+        setmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);
+        mm_update_next_owner(old_mm);
+        mmput(old_mm);
+        return 0;
+    }
+    
+    mmdrop(active_mm);
+    return 0;
 }
 
 SYSCALL_DEFINE1(as_destroy, unsigned int, fd)
 {
-    return -ENOSYS;
+    struct mm_struct *mm;
+    struct task_struct *task;
+
+    task = current;
+    mm = get_mm_from_fd(fd);
+    if (IS_ERR(mm)) {
+        return PTR_ERR(mm);
+    }
+
+    __close_fd(current->files, fd);
+
+    return 0;
+}
+
+static int as_release(struct inode *inode, struct file *file)
+{
+    struct mm_struct *mm = file->private_data;
+
+    mmput(mm);
+    return 0;
 }
diff --git a/mm/as.h b/mm/as.h
new file mode 100644
index 000000000000..4542c9b28ec5
--- /dev/null
+++ b/mm/as.h
@@ -0,0 +1,18 @@
+#ifndef ___AS__H
+#define ___AS__H
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+extern struct file *get_empty_filp(void);
+
+struct mmap_info {
+    unsigned long addr;
+    unsigned long len;
+    unsigned long prot;
+    unsigned long flags;
+    unsigned long fd;
+    unsigned long offset;
+};
+
+#endif
-- 
2.19.0.rc1


From 0eac0deec9a963d2cde03546f200ec03ed630d4d Mon Sep 17 00:00:00 2001
From: Yang Bo <bo@hyper.sh>
Date: Tue, 25 Sep 2018 13:47:05 +0800
Subject: [PATCH 4/4] Add as_copy for test purpose.

Signed-off-by: Yang Bo <bo@hyper.sh>
---
 arch/x86/entry/syscalls/syscall_64.tbl |   1 +
 kernel/fork.c                          |   2 +-
 mm/as.c                                | 135 ++++++++++++++++++++++++-
 mm/as.h                                |   1 +
 4 files changed, 134 insertions(+), 5 deletions(-)

diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 3ee0ebc2d6f1..3e9a24fae208 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -347,6 +347,7 @@
 336 common  as_mprotect     __x64_sys_as_mprotect
 337 common  as_switch_mm    __x64_sys_as_switch_mm
 338 common  as_destroy      __x64_sys_as_destroy
+339 common  as_copy         __x64_sys_as_copy
 
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
diff --git a/kernel/fork.c b/kernel/fork.c
index b9d9b39d4afc..e3bb7a62470e 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1250,7 +1250,7 @@ void mm_release(struct task_struct *tsk, struct mm_struct *mm)
  * Allocate a new mm structure and copy contents from the
  * mm structure of the passed in task structure.
  */
-static struct mm_struct *dup_mm(struct task_struct *tsk)
+struct mm_struct *dup_mm(struct task_struct *tsk)
 {
 	struct mm_struct *mm, *oldmm = current->mm;
 	int err;
diff --git a/mm/as.c b/mm/as.c
index 016fc7eb5547..fae2b7da58b4 100644
--- a/mm/as.c
+++ b/mm/as.c
@@ -20,12 +20,18 @@
 #include <asm/mmu_context.h>
 #include "as.h"
 
+
+#define DEBUG
 // static long mm_nr = 0;
 
 static int as_release(struct inode *inode, struct file *file);
+#ifdef DEBUG
+static void dump_pt_regs(struct pt_regs *reg);
+#endif
+static long do_as_switch_mm(unsigned int fd);
 struct file_operations as_fops = {
     .release = as_release,
-    };
+};
 
 
 static struct mm_struct *get_mm_from_fd(int fd)
@@ -66,6 +72,46 @@ SYSCALL_DEFINE0(as_create)
         return fd;
     }
 
+    /* add to mmlist? */
+    spin_lock(&mmlist_lock);
+    list_add(&mm->mmlist, &current->mm->mmlist);
+    /* looks like we will never go back to the initial mm..
+     * Therefore, let it vanish
+     * */
+#if 0
+    if (!mm_nr) {
+        mmget(current->mm);
+        mm_nr++;
+    }
+#endif
+    spin_unlock(&mmlist_lock);
+
+    return fd;
+}
+
+/* copy mm struct from current mm struct.
+ * used for test code. Or might be usefull..
+ * However, this is COW. Therfore, If we switch to
+ * this mm later, it results in weird execution path
+ * and segv..
+ * */
+SYSCALL_DEFINE0(as_copy)
+{
+    int fd, ret;
+    struct mm_struct *mm;
+    struct task_struct *task;
+
+    task = current;
+    mm = dup_mm(task);
+    if (!mm) {
+        return -ENOMEM;
+    }
+
+    fd = anon_inode_getfd("[adress-space]", &as_fops, mm, 0);
+    if (fd < 0) {
+        mmput(mm);
+        return fd;
+    }
 
     /* add to mmlist? */
     spin_lock(&mmlist_lock);
@@ -81,6 +127,14 @@ SYSCALL_DEFINE0(as_create)
 #endif
     spin_unlock(&mmlist_lock);
 
+#ifdef DEBUG
+    ret = do_as_switch_mm(fd);
+    if (ret) {
+        __close_fd(current->files, fd);
+        return ret;
+    }
+#endif
+
     return fd;
 }
 
@@ -137,11 +191,25 @@ SYSCALL_DEFINE4(as_mprotect, unsigned int, fd, unsigned long, addr,
     return do_mprotect_pkey2(mm, addr, len, prot, -1);;
 }
 
-SYSCALL_DEFINE1(as_switch_mm, unsigned int, fd)
+static long do_as_switch_mm(unsigned int fd)
 {
     struct mm_struct *mm, *old_mm, *active_mm;
     struct task_struct *tsk = current;
-
+    struct pt_regs *old, *new;
+    mm_segment_t oldfs;
+    unsigned long oldfs2, oldgs;
+    unsigned int fsindex, gsindex;
+
+    oldfs = get_fs();
+    rdmsrl(MSR_FS_BASE, oldfs2);
+    rdmsrl(MSR_KERNEL_GS_BASE, oldgs);
+    savesegment(fs, fsindex);
+    savesegment(gs, gsindex);
+#ifdef DEBUG
+    printk(KERN_INFO "oldfs[%lx], fsbase[%lx], gsbase[%lx]\n", oldfs.seg,
+            oldfs2, oldgs);
+    printk(KERN_INFO "fsindex[%x], gsindex[%x]\n", fsindex, gsindex);
+#endif
     mm = get_mm_from_fd(fd);
     if (IS_ERR(mm)) {
         return PTR_ERR(mm);
@@ -153,6 +221,14 @@ SYSCALL_DEFINE1(as_switch_mm, unsigned int, fd)
         return 0;
     }
 
+#ifdef DEBUG
+    /* check pt_regs before and after switch mm.
+     * looks like the return address is messed up.. 
+     * */
+    old = task_pt_regs(current);
+    dump_pt_regs(old);
+#endif
+
     mm_release(tsk, old_mm);
 
     /* we are not kernel thread.
@@ -179,19 +255,36 @@ SYSCALL_DEFINE1(as_switch_mm, unsigned int, fd)
     /* simply mmput/mmdrop will cause the initial mm of this task
      * vanish.. hmmm.. Not sure if need to keep it.
      * */
+#ifdef DEBUG
+    new = task_pt_regs(current);
+    dump_pt_regs(new);
+#endif
     if (old_mm) {
         up_read(&old_mm->mmap_sem);
         BUG_ON(active_mm != old_mm);
         setmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);
         mm_update_next_owner(old_mm);
         mmput(old_mm);
-        return 0;
+        goto out;
     }
     
     mmdrop(active_mm);
+
+out:
+//    set_fs(oldfs);
+    set_fs(USER_DS);
+    wrmsrl(MSR_FS_BASE, oldfs2);
+    wrmsrl(MSR_KERNEL_GS_BASE, oldgs);
+    loadsegment(fs, fsindex);
+    load_gs_index(gsindex);
     return 0;
 }
 
+SYSCALL_DEFINE1(as_switch_mm, unsigned int, fd)
+{
+    return do_as_switch_mm(fd);
+}
+
 SYSCALL_DEFINE1(as_destroy, unsigned int, fd)
 {
     struct mm_struct *mm;
@@ -215,3 +308,37 @@ static int as_release(struct inode *inode, struct file *file)
     mmput(mm);
     return 0;
 }
+
+#ifdef DEBUG
+static void dump_pt_regs(struct pt_regs *reg)
+{
+    int i = 0;
+    char *c, ch;
+    printk(KERN_INFO "r15[%lx], r14[%lx], r13[%lx], r12[%lx]\n",
+            reg->r15, reg->r14, reg->r13, reg->r12);
+    printk(KERN_INFO "bp[%lx], bx[%lx], r11[%lx], r10[%lx]\n",
+            reg->bp, reg->bx, reg->r11, reg->r10);
+    printk(KERN_INFO "r9[%lx], r8[%lx], ax[%lx], cx[%lx]\n",
+            reg->r9, reg->r8, reg->ax, reg->cx);
+    printk(KERN_INFO "dx[%lx], si[%lx], di[%lx], orig_ax[%lx]\n",
+            reg->dx, reg->si, reg->di, reg->orig_ax);
+    printk(KERN_INFO "ip[%lx], cs[%lx], flags[%lx], sp[%lx]\n",
+            reg->ip, reg->cs, reg->flags, reg->sp);
+    printk(KERN_INFO "ss[%lx]\n", reg->ss);
+#if 0
+    printk(KERN_INFO "dump instructions:\n");
+    c = (char *)reg->ip;
+    for (i = 0; i < 50; i++, c++) {
+        if (get_user(ch, c)) {
+            printk(KERN_INFO "bug ");
+            continue;
+        }
+        printk(KERN_INFO "%02x ", ch);
+        if (i % 10 == 9) {
+            printk(KERN_INFO "\n");
+        }
+    }
+#endif
+    return;
+}
+#endif
diff --git a/mm/as.h b/mm/as.h
index 4542c9b28ec5..dd4646bcdcf7 100644
--- a/mm/as.h
+++ b/mm/as.h
@@ -5,6 +5,7 @@
 #include <linux/kernel.h>
 
 extern struct file *get_empty_filp(void);
+extern struct mm_struct *dup_mm(struct task_struct *task);
 
 struct mmap_info {
     unsigned long addr;
-- 
2.19.0.rc1

